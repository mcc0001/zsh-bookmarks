#!/usr/bin/env zsh

# Initialize color variables
typeset -gA c
: ${c[reset]:=$'\e[0m'}
: ${c[green]:=$'\e[32m'}
: ${c[blue]:=$'\e[34m'}   # For paths
: ${c[cyan]:=$'\e[36m'}   # For bookmark names

# Fixed color application
@bookmark_name_colorize() { print -n -- "${c[blue]}$1${c[reset]}" }
@bookmark_path_colorize() { print -n -- "${c[cyan]}$1${c[reset]}" }

local bookmark_file="$(<"$ZPM_BOOKMARKS_FILE")"
local bookmark_path
local bookmark_name
local output_sep=" ${c[green]}âž”${c[reset]} "  # Green arrow separator

if [[ -n "$1" ]]; then
  # For single bookmark lookup
  @bookmark_path_colorize "$(grep -E "\|${1}$" <<< "$bookmark_file" | awk -F'|' '{print $1}')"
  echo
else
  # First pass: compute max name width
  local max_name_width=0
  while IFS= read -r line; do
    bookmark_name="${line#*|}"
    [[ -n "$bookmark_name" ]] && (( ${#bookmark_name} > max_name_width )) && max_name_width=${#bookmark_name}
  done <<< "$bookmark_file"

  # Second pass: print aligned output with correct colors
  while IFS= read -r line; do
    bookmark_path="${line%|*}"
    bookmark_name="${line#*|}"

    if [[ -n "$bookmark_path" && -n "$bookmark_name" ]]; then
      # Apply colors directly to the correct elements
      local colored_name="$(@bookmark_name_colorize $bookmark_name)"
      local colored_path="$(@bookmark_path_colorize $bookmark_path)"
      local padding_width=$(( max_name_width - ${#bookmark_name} ))
      
      # Print with proper formatting
      printf "  %s%${padding_width}s%s %s\n" "$colored_name" "" "$output_sep" "$colored_path"
    fi
  done <<< "$bookmark_file"
fi
